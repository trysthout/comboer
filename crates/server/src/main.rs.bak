use std::fmt::format;

use proto::{epmd::EpmdClient, etf::term, SendCtrl, RegSend, Dist, Encoder, CtrlMsg, SendSender, Len};
use server::node::{NodePrimitive, AsServer, AsClient, Handler, TuplePattern, AtomPattern, PatternMatch};
use tokio::{net::{TcpStream, TcpListener}, io::{AsyncReadExt, AsyncWriteExt}};
use tokio_stream::{wrappers::TcpListenerStream, StreamExt};

#[derive(Debug, Clone)]
struct A;
#[async_trait::async_trait]
impl Handler for A {
   type Error = anyhow::Error; 

   async fn reg_send(self, stream: &mut TcpStream, _ctrl: RegSend, msg: term::Term) -> Result<Self, Self::Error> {
        if let Ok(tuple) = term::SmallTuple::try_from(msg.clone()) {
            if let Ok(p) = term::NewPid::try_from(&tuple.elems[1]) {
                let mut data = vec![];
                let reg = SendCtrl {
                    unused: term::SmallAtomUtf8("".to_string()),
                    to: p,
                };

                let msg = term::SmallAtomUtf8("ccccccccccccccccc".to_string());
                let dist = Dist {
                    ctrl_msg: reg.into(),
                    msg: Some(msg.into()),
                };

                dist.encode(&mut data)?;
                println!("data1 {:?}", data);

                stream.write(&data).await?;
            }
        }

        Ok(self)
   }

   async fn send_sender(self, stream: &mut TcpStream, ctrl: SendSender, msg: term::Term) -> Result<Self, Self::Error> {
        let from = ctrl.from;
        let ctrl = SendCtrl {
            unused: term::SmallAtomUtf8("".to_string()),
            to: from,
        };
        let dist = Dist {
            ctrl_msg: ctrl.clone().into(),
            msg: Some(term::SmallTuple {
                arity: 2,
                elems: vec![
                    term::SmallAtomUtf8("from_rust".to_string()).into(),
                    term::SmallAtomUtf8("rust node".to_string()).into(),
                ],
            }.into()),
        };

        let mut buf = Vec::with_capacity(dist.len());
        dist.encode(&mut buf)?;
        stream.write(&buf).await?;

        Ok(self)
   }
}

#[tokio::main]
async fn main() {
    let mut node = NodePrimitive::new("rust".to_string(), "aaa".to_string());
    node.listen("127.0.0.1:4369", A).await.unwrap();
}

//#[tokio::main]
//async fn main() -> Result<(), anyhow::Error> {
//    let mut node = NodePrimitive::new("rust@fedora".to_string(), "aaa".to_string());
//    let mut client = node.connect_local_by_name("127.0.0.1:4369", "b").await?;
//
//    let from = term::NewPid { 
//            node: term::SmallAtomUtf8("rust@fedora".to_string()), 
//            id: 0, 
//            serial: 0, 
//            creation: fastrand::u32(..),
//    }; 
//
//    let ctrl = RegSend { 
//        from: from.clone(), 
//        unused: term::SmallAtomUtf8("".to_string()), 
//        to_name: term::SmallAtomUtf8("ss".to_string()), 
//    }.into();
//
//    let msg = term::SmallTuple{
//        arity: 2,
//        elems: vec![
//            term::SmallAtomUtf8("call".to_string()).into(),
//            from.clone().into(),
//        ]
//    }.into();
//
//    let pattern = AtomPattern("hi".to_string());
//    let pattern_fn = |term: &term::Term| -> bool {
//       term::SmallAtomUtf8::try_from(term).map(|t| t.pattern_match(&pattern)).ok().unwrap_or_default() 
//    };
//    //res.send(ctrl, msg).await?;
//    let res = client.send_and_wait(ctrl, msg, pattern_fn).await?;
//    if let Some(dist) = res {
//        if let CtrlMsg::SendSender(ctrl) = dist.ctrl_msg {
//            let from = ctrl.from;
//            let ctrl = SendCtrl {
//                unused: term::SmallAtomUtf8("".to_string()),
//                to: from,
//            }.into();
//            let msg = term::SmallTuple {
//                    arity: 2,
//                    elems: vec![
//                        term::SmallAtomUtf8("from_rust".to_string()).into(),
//                        term::SmallAtomUtf8("rust node".to_string()).into(),
//                    ],
//                }.into();
//
//            client.send(ctrl, msg).await?;
//        }
//    }
//
//    Ok(())
//    //let stream = TcpStream::connect("127.0.0.1:4369").await.unwrap();
//    //let _ = stream.set_nodelay(true);
//    //let mut framed = Node::init(stream, 11111).await?;
//    //tokio::spawn(async move {
//    //   while let Some(Ok(_resp)) = framed.next().await {
//    //       
//    //   } 
//    //});
//
//
//    //let mut node = Node::new(false);
//    //let stream = TcpStream::connect("192.168.1.6:46483").await.unwrap();
//    //let _ = stream.set_nodelay(true);
//    //node.start(stream).await
//}